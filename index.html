<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#ffffff">
    <title>Market Dynamic Watch</title>
    
    <link rel="manifest" href="manifest.json">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background-color: #f5f5f8;
            color: #1d1d1f;
            line-height: 1.6;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Header */
        .header {
            position: sticky;
            top: 0;
            background-color: #ffffff;
            border-bottom: 1px solid #e0e0e5;
            z-index: 100;
            padding: 1rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.06);
        }

        .header-content {
            max-width: 600px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .back-button {
            background: none;
            border: none;
            color: #1d1d1f;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 6px;
            transition: background-color 0.2s;
        }

        .back-button:hover {
            background-color: #e8e8ed;
        }

        /* Container */
        .container {
            max-width: 600px;
            margin: 0 auto;
            min-height: calc(100vh - 80px);
        }

        /* Views */
        .view {
            display: none;
            padding: 0;
        }

        .view.active {
            display: block;
        }

        /* Pull to Refresh */
        .ptr-container {
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .ptr-indicator {
            text-align: center;
            padding: 0;
            height: 0;
            overflow: hidden;
            transition: height 0.2s ease, opacity 0.2s ease;
            opacity: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
            font-size: 0.85rem;
        }

        .ptr-indicator.pulling {
            opacity: 1;
        }

        .ptr-indicator.refreshing {
            height: 50px;
            opacity: 1;
        }

        .ptr-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #ddd;
            border-top-color: #666;
            border-radius: 50%;
            margin-right: 8px;
        }

        .ptr-indicator.refreshing .ptr-spinner {
            animation: ptr-spin 0.8s linear infinite;
        }

        @keyframes ptr-spin {
            to { transform: rotate(360deg); }
        }

        /* Hide TradingView attribution */
        [class*="attribution"], 
        a[href*="tradingview.com"] {
            display: none !important;
        }

        /* List View */
        .list-view {
            padding: 0;
        }

        .category-section {
            margin-bottom: 1.5rem;
        }

        .category-header {
            padding: 1rem 1rem 0.5rem;
            font-size: 0.8rem;
            font-weight: 600;
            color: #6e6e73;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .asset-list {
            background-color: #ffffff;
            margin: 0 1rem;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        }

        .asset-row {
            display: flex;
            align-items: center;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #f0f0f3;
            cursor: pointer;
            transition: background-color 0.2s;
            min-height: 60px;
        }

        .asset-row:last-child {
            border-bottom: none;
        }

        .asset-row:hover {
            background-color: #f5f5f8;
        }

        .asset-icon {
            font-size: 1.2rem;
            width: 2rem;
            text-align: center;
            margin-right: 0.75rem;
        }

        .asset-info {
            flex: 1;
            min-width: 0;
        }

        .asset-name {
            font-size: 0.9rem;
            font-weight: 600;
            color: #1d1d1f;
            margin-bottom: 0.1rem;
        }

        .asset-symbol {
            font-size: 0.75rem;
            color: #8e8e93;
        }

        .asset-price {
            text-align: right;
            margin-right: 0.75rem;
            min-width: 0;
        }

        .price {
            font-size: 0.9rem;
            font-weight: 600;
            color: #1d1d1f;
            margin-bottom: 0.1rem;
        }

        .change {
            font-size: 0.8rem;
            font-weight: 600;
        }

        .change.positive {
            color: #00a061;
        }

        .change.negative {
            color: #e03c32;
        }

        .change.neutral {
            color: #8e8e93;
        }

        .sparkline-container {
            width: 50px;
            height: 30px;
            margin-left: 0.5rem;
        }

        .sparkline {
            width: 100%;
            height: 100%;
        }

        /* Detail View */
        .detail-view {
            background-color: #ffffff;
            margin: 1rem;
            border-radius: 10px;
            padding: 1.5rem !important;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        }

        .detail-header {
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .detail-name {
            font-size: 1rem;
            font-weight: 500;
            color: #8e8e93;
            margin-bottom: 0.25rem;
        }

        .detail-price {
            font-size: 2.5rem;
            font-weight: 700;
            color: #1d1d1f;
            margin-bottom: 0.25rem;
        }

        .detail-change {
            font-size: 1rem;
            font-weight: 600;
        }

        .time-range-buttons {
            display: flex;
            background-color: #f0f0f3;
            border-radius: 8px;
            padding: 0.25rem;
            margin-bottom: 1rem;
        }

        .time-range-button {
            flex: 1;
            background: none;
            border: none;
            color: #8e8e93;
            font-size: 0.8rem;
            font-weight: 600;
            padding: 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .time-range-button.active {
            background-color: #ffffff;
            color: #1d1d1f;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .chart-container {
            background-color: #ffffff;
            border-radius: 8px;
            height: 300px;
            margin-bottom: 1rem;
            position: relative;
        }

        /* Loading and Error States */
        .loading {
            text-align: center;
            padding: 2rem;
            color: #8e8e93;
        }

        .error {
            text-align: center;
            padding: 2rem;
            color: #e03c32;
        }

        .loading-spinner {
            border: 2px solid #e0e0e5;
            border-top: 2px solid #8e8e93;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            margin: 0 auto 0.5rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Connection Status */
        .status-indicator {
            position: fixed;
            top: 1rem;
            right: 1rem;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #e03c32;
            z-index: 1000;
            transition: background-color 0.3s;
        }

        .status-indicator.online {
            background-color: #00a061;
        }

        /* Responsive */
        @media (max-width: 480px) {
            .asset-row {
                padding: 0.6rem 0.8rem;
            }
            
            .asset-icon {
                font-size: 1rem;
                margin-right: 0.5rem;
                width: 1.5rem;
            }
            
            .detail-price {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="status-indicator" id="status"></div>
    
    <header class="header">
        <div class="header-content">
            <button class="back-button" id="backButton" style="display: none;" onclick="app.goBack()">
                ‚Üê
            </button>
            <h1 id="headerTitle">Market Dynamic Watch</h1>
            <div style="width: 2rem;"></div> <!-- Spacer for centering -->
        </div>
    </header>

    <div class="container">
        <!-- List View -->
        <div class="ptr-indicator" id="ptrIndicator">
            <span class="ptr-spinner"></span>
            <span class="ptr-text">‰∏ãÊãâÂà∑Êñ∞</span>
        </div>
        <div class="view list-view active" id="listView">
            <div id="marketList">
                <div class="loading">
                    <div class="loading-spinner"></div>
                    Loading markets...
                </div>
            </div>
        </div>

        <!-- Detail View -->
        <div class="view detail-view" id="detailView">
            <div class="detail-header" id="detailHeader">
                <div class="detail-name" id="detailName"></div>
                <div class="detail-price" id="detailPrice"></div>
                <div class="detail-change" id="detailChange"></div>
            </div>
            
            <div class="time-range-buttons" id="timeRangeButtons">
                <button class="time-range-button" data-range="1d">‰ªäÊó•</button>
                <button class="time-range-button active" data-range="3mo">3M</button>
                <button class="time-range-button" data-range="1y">1Y</button>
                <span id="tzLabel" style="font-size:0.7rem;color:#999;margin-left:8px;display:none;">ET</span>
            </div>
            
            <div class="chart-container" id="chartContainer">
                <div class="loading">
                    <div class="loading-spinner"></div>
                    Loading chart...
                </div>
            </div>
        </div>
    </div>

    <!-- TradingView Lightweight Charts -->
    <script src="https://unpkg.com/lightweight-charts@5.1.0/dist/lightweight-charts.standalone.production.js"></script>
    
    <script>
        // Configuration - Auto-detect environment
        const API_BASE_URL = ''; // Same-origin: Vercel serves both static + API
        const UPDATE_INTERVAL = 30000; // 30 seconds

        class MarketDashboard {
            constructor() {
                this.config = null;
                this.data = new Map();
                this.websocket = null;
                this.chart = null;
                this.currentSymbol = null;
                this.updateTimer = null;
                this.init();
            }

            async init() {
                try {
                    await this.loadConfig();
                    this.setupRouter();
                    this.setupEventListeners();
                    await this.loadData();
                    this.renderList();
                    this.setupWebSocket();
                    this.startUpdateTimer();
                    this.updateStatus('online');
                } catch (error) {
                    console.error('Init error:', error);
                    this.showError('Failed to load market data');
                    this.updateStatus('offline');
                }
            }

            async loadConfig() {
                const response = await fetch('./config.json');
                if (!response.ok) throw new Error('Failed to load config');
                this.config = await response.json();
            }

            setupRouter() {
                window.addEventListener('hashchange', () => this.handleRoute());
                this.handleRoute();
            }

            handleRoute() {
                const hash = window.location.hash.slice(1);
                
                if (hash.startsWith('/detail/')) {
                    const symbol = decodeURIComponent(hash.replace('/detail/', ''));
                    this.showDetail(symbol);
                } else {
                    this.showList();
                }
            }

            setupEventListeners() {
                // Time range buttons
                document.getElementById('timeRangeButtons').addEventListener('click', (e) => {
                    if (e.target.classList.contains('time-range-button')) {
                        const range = e.target.dataset.range;
                        this.changeTimeRange(range);
                    }
                });

                // Pull to refresh
                this.setupPullToRefresh();
            }

            setupPullToRefresh() {
                const indicator = document.getElementById('ptrIndicator');
                const textEl = indicator.querySelector('.ptr-text');
                let startY = 0;
                let pulling = false;
                let refreshing = false;
                const threshold = 70;

                const onTouchStart = (e) => {
                    if (refreshing) return;
                    if (window.scrollY > 5) return;
                    startY = e.touches[0].clientY;
                    pulling = true;
                };

                const onTouchMove = (e) => {
                    if (!pulling || refreshing) return;
                    const dy = e.touches[0].clientY - startY;
                    if (dy < 0) { pulling = false; return; }
                    if (window.scrollY > 5) { pulling = false; return; }

                    const progress = Math.min(dy / threshold, 1);
                    const height = Math.min(dy * 0.5, 60);
                    indicator.style.height = height + 'px';
                    indicator.classList.add('pulling');

                    if (dy >= threshold) {
                        textEl.textContent = 'ÊùæÂºÄÂà∑Êñ∞';
                    } else {
                        textEl.textContent = '‰∏ãÊãâÂà∑Êñ∞';
                    }
                };

                const onTouchEnd = async (e) => {
                    if (!pulling) return;
                    const dy = (e.changedTouches[0]?.clientY || 0) - startY;
                    pulling = false;

                    if (dy >= threshold && !refreshing) {
                        refreshing = true;
                        indicator.classList.remove('pulling');
                        indicator.classList.add('refreshing');
                        textEl.textContent = 'Âà∑Êñ∞‰∏≠...';

                        try {
                            await this.loadData();
                            this.renderList();
                            textEl.textContent = 'Â∑≤Êõ¥Êñ∞';
                        } catch (err) {
                            textEl.textContent = 'Âà∑Êñ∞Â§±Ë¥•';
                        }

                        setTimeout(() => {
                            indicator.classList.remove('refreshing');
                            indicator.style.height = '0';
                            indicator.style.opacity = '0';
                            refreshing = false;
                            setTimeout(() => {
                                indicator.style.opacity = '';
                            }, 200);
                        }, 600);
                    } else {
                        indicator.classList.remove('pulling');
                        indicator.style.height = '0';
                    }
                };

                document.addEventListener('touchstart', onTouchStart, { passive: true });
                document.addEventListener('touchmove', onTouchMove, { passive: true });
                document.addEventListener('touchend', onTouchEnd, { passive: true });
            }

            async loadData() {
                try {
                    // Collect all symbols for batch real-time fetch
                    const allSymbols = [];
                    const yahooSymbols = [];
                    this.config.categories.forEach(category => {
                        category.assets.forEach(asset => {
                            allSymbols.push(asset.symbol);
                            yahooSymbols.push(asset.yahoo_symbol || asset.symbol);
                        });
                    });

                    if (allSymbols.length === 0) return;

                    // Use /api/quotes for batch real-time data (EODHD primary, Yahoo fallback)
                    const quotesUrl = `${API_BASE_URL}/api/quotes?symbols=${encodeURIComponent(allSymbols.join(','))}&yahoo_symbols=${encodeURIComponent(yahooSymbols.join(','))}`;
                    const resp = await fetch(quotesUrl);
                    if (resp.ok) {
                        const quotesData = await resp.json();
                        for (const sym of allSymbols) {
                            if (quotesData[sym]) {
                                this.data.set(sym, quotesData[sym]);
                            }
                        }
                    }
                } catch (error) {
                    console.error('Data loading error:', error);
                    throw error;
                }
            }

            renderList() {
                const listElement = document.getElementById('marketList');
                
                if (!this.config) {
                    listElement.innerHTML = '<div class="error">Config not loaded</div>';
                    return;
                }

                let html = '';
                
                this.config.categories.forEach(category => {
                    html += `
                        <div class="category-section">
                            <div class="category-header">${category.name}</div>
                            <div class="asset-list">
                                ${category.assets.map(asset => this.renderAssetRow(asset)).join('')}
                            </div>
                        </div>
                    `;
                });

                listElement.innerHTML = html;
                
                // Draw sparklines
                setTimeout(() => this.drawSparklines(), 100);
            }

            renderAssetRow(asset) {
                const data = this.data.get(asset.symbol) || {};
                const rawPrice = (data.price || 0) * (asset.price_multiplier || 1);
                const price = this.formatPrice(rawPrice, asset);
                const changePercent = data.change_pct || 0;
                const changeClass = changePercent > 0 ? 'positive' : changePercent < 0 ? 'negative' : 'neutral';
                const changeSymbol = changePercent > 0 ? '+' : '';

                return `
                    <div class="asset-row" onclick="app.goToDetail('${asset.symbol}')">
                        <div class="asset-icon">${asset.icon || 'üìà'}</div>
                        <div class="asset-info">
                            <div class="asset-name">${asset.name}</div>
                            <div class="asset-symbol">${asset.display_symbol || asset.symbol}</div>
                        </div>
                        <div class="asset-price">
                            <div class="price">${price}</div>
                            <div class="change ${changeClass}">
                                ${changeSymbol}${changePercent.toFixed(2)}%
                            </div>
                        </div>
                    </div>
                `;
            }

            formatPrice(price, asset) {
                if (!price || price === 0) return 'N/A';
                
                let finalPrice = price;
                
                if (finalPrice >= 1000) {
                    return `$${finalPrice.toLocaleString('en-US', { maximumFractionDigits: 2 })}`;
                } else if (finalPrice >= 1) {
                    return `$${finalPrice.toFixed(4)}`;
                } else {
                    return `$${finalPrice.toFixed(6)}`;
                }
            }

            drawSparklines() {
                const canvases = document.querySelectorAll('.sparkline');
                canvases.forEach(canvas => {
                    const symbol = canvas.dataset.symbol;
                    const data = this.data.get(symbol);
                    
                    if (data && data.sparkline && data.sparkline.length > 0) {
                        this.drawSparkline(canvas, data.sparkline);
                    }
                });
            }

            drawSparkline(canvas, prices) {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);
                
                if (prices.length < 2) return;
                
                const min = Math.min(...prices);
                const max = Math.max(...prices);
                const range = max - min || 1;
                
                // Determine color based on trend
                const isUp = prices[prices.length - 1] > prices[0];
                ctx.strokeStyle = isUp ? '#00a061' : '#e03c32';
                ctx.lineWidth = 1.5;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                prices.forEach((price, index) => {
                    const x = (index / (prices.length - 1)) * width;
                    const y = height - ((price - min) / range) * height;
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
            }

            setupWebSocket() {
                // WebSocket removed ‚Äî all data fetched via EODHD/Yahoo REST APIs
                // Periodic polling via startUpdateTimer() handles refreshes
            }

            startUpdateTimer() {
                this.updateTimer = setInterval(() => {
                    this.loadData().then(() => {
                        if (this.getCurrentView() === 'list') {
                            this.renderList();
                        } else if (this.currentSymbol) {
                            // Update detail page price header
                            this.updateDetailPrice(this.currentSymbol);
                        }
                    }).catch(error => {
                        console.error('Update error:', error);
                    });
                }, UPDATE_INTERVAL);
            }

            updateDetailPrice(symbol) {
                const data = this.data.get(symbol) || {};
                const asset = this.findAssetBySymbol(symbol);
                const rawPrice = (data.price || 0) * (asset ? (asset.price_multiplier || 1) : 1);
                const price = this.formatPrice(rawPrice, asset || {});
                document.getElementById('detailPrice').textContent = price;

                const changePercent = data.change_pct || 0;
                const changeClass = changePercent > 0 ? 'positive' : changePercent < 0 ? 'negative' : 'neutral';
                const changeSymbol = changePercent > 0 ? '+' : '';
                const changeEl = document.getElementById('detailChange');
                if (changeEl) {
                    changeEl.textContent = `${changeSymbol}${changePercent.toFixed(2)}%`;
                    changeEl.className = `detail-change ${changeClass}`;
                }
            }

            getCurrentView() {
                return document.querySelector('.view.active').id === 'listView' ? 'list' : 'detail';
            }

            goToDetail(symbol) {
                window.location.hash = `#/detail/${symbol}`;
            }

            goBack() {
                window.location.hash = '#/';
            }

            showList() {
                document.getElementById('listView').classList.add('active');
                document.getElementById('detailView').classList.remove('active');
                document.getElementById('backButton').style.display = 'none';
                document.getElementById('headerTitle').textContent = 'Market Dynamic Watch';
                this.currentSymbol = null;
                
                if (this.chart) {
                    this.chart.remove();
                    this.chart = null;
                }
            }

            async showDetail(symbol) {
                document.getElementById('listView').classList.remove('active');
                document.getElementById('detailView').classList.add('active');
                document.getElementById('backButton').style.display = 'block';
                
                this.currentSymbol = symbol;

                // Reset tab to 3M default
                document.querySelectorAll('.time-range-button').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.range === '3mo');
                });
                const tzLabel = document.getElementById('tzLabel');
                if (tzLabel) tzLabel.style.display = 'none';

                // If data not loaded yet, fetch real-time quote
                if (!this.data.has(symbol)) {
                    try {
                        const asset = this.findAssetBySymbol(symbol);
                        const yahooSym = asset ? (asset.yahoo_symbol || symbol) : symbol;
                        const resp = await fetch(`${API_BASE_URL}/api/quotes?symbols=${encodeURIComponent(symbol)}&yahoo_symbols=${encodeURIComponent(yahooSym)}`);
                        if (resp.ok) {
                            const quotesData = await resp.json();
                            if (quotesData[symbol]) {
                                this.data.set(symbol, quotesData[symbol]);
                            }
                        }
                    } catch (e) { console.warn('Detail quote fetch failed:', e); }
                }

                this.updateDetailHeader(symbol);
                this.loadChart(symbol, '3mo');
            }

            updateDetailHeader(symbol) {
                const asset = this.findAssetBySymbol(symbol);
                const data = this.data.get(symbol) || {};
                
                document.getElementById('headerTitle').textContent = asset ? asset.name : symbol;
                document.getElementById('detailName').textContent = asset ? `${asset.name} (${asset.display_symbol || symbol})` : symbol;
                
                const rawPrice = (data.price || 0) * (asset ? (asset.price_multiplier || 1) : 1);
                const price = this.formatPrice(rawPrice, asset || {});
                document.getElementById('detailPrice').textContent = price;
                
                const changePercent = data.change_pct || 0;
                const changeClass = changePercent > 0 ? 'positive' : changePercent < 0 ? 'negative' : 'neutral';
                const changeSymbol = changePercent > 0 ? '+' : '';
                const changeEl = document.getElementById('detailChange');
                changeEl.textContent = `${changeSymbol}${changePercent.toFixed(2)}%`;
                changeEl.className = `detail-change ${changeClass}`;
            }

            findAssetBySymbol(symbol) {
                for (const category of this.config.categories) {
                    for (const asset of category.assets) {
                        if (asset.symbol === symbol) {
                            return asset;
                        }
                    }
                }
                return null;
            }

            async loadChart(symbol, range) {
                const container = document.getElementById('chartContainer');
                container.innerHTML = `
                    <div class="loading">
                        <div class="loading-spinner"></div>
                        Loading chart...
                    </div>
                `;

                try {
                    const asset = this.findAssetBySymbol(symbol);
                    const yahooSym = asset ? (asset.yahoo_symbol || symbol) : symbol;
                    let chartData;
                    
                    // Map display range to API params
                    // 1d ‚Üí intraday 5m; 3mo/1y ‚Üí eod daily
                    const apiRange = range === '1d' ? '5d' : range;
                    const interval = range === '1d' ? '5m' : '1d';
                    const response = await fetch(
                        `${API_BASE_URL}/api/chart?symbol=${encodeURIComponent(symbol)}`
                        + `&range=${apiRange}&interval=${interval}`
                        + `&yahoo_symbol=${encodeURIComponent(yahooSym)}`
                    );
                    if (!response.ok) throw new Error('Failed to load chart');
                    const result = await response.json();
                    chartData = result.data || [];
                    const timeFormat = result.time_format || 'timestamp';

                    if (chartData.length === 0) {
                        container.innerHTML = '<div class="error">ÊöÇÊó†Êï∞ÊçÆ</div>';
                        return;
                    }

                    // Intraday uses line chart, daily uses candlestick
                    if (range === '1d') {
                        // Filter to current trading session based on asset type
                        chartData = this.filterTodayData(chartData, asset);
                        if (chartData.length === 0) {
                            container.innerHTML = '<div class="error">ÊöÇÊó†‰ªäÊó•Êï∞ÊçÆ</div>';
                            return;
                        }
                        this.renderLineChart(chartData);
                    } else {
                        this.renderChart(chartData, timeFormat);
                    }
                } catch (error) {
                    console.error('Chart loading error:', error);
                    container.innerHTML = '<div class="error">Failed to load chart</div>';
                }
            }

            // Binance chart removed ‚Äî crypto now uses EODHD via /api/chart

            renderLineChart(data) {
                const container = document.getElementById('chartContainer');
                container.innerHTML = '';

                if (this.chart) {
                    this.chart.remove();
                }

                this.chart = LightweightCharts.createChart(container, {
                    width: container.clientWidth,
                    height: 300,
                    attributionLogo: false,
                    layout: {
                        background: { color: '#ffffff' },
                        textColor: '#6e6e73',
                    },
                    grid: {
                        vertLines: { color: '#f0f0f3' },
                        horzLines: { color: '#f0f0f3' },
                    },
                    crosshair: {
                        mode: LightweightCharts.CrosshairMode.Normal,
                    },
                    localization: {
                        timeFormatter: (timestamp) => {
                            const d = new Date(timestamp * 1000);
                            return d.toLocaleTimeString('en-US', {
                                timeZone: 'America/New_York',
                                hour: '2-digit',
                                minute: '2-digit',
                                hour12: false,
                            });
                        },
                    },
                    timeScale: {
                        borderColor: '#e0e0e5',
                        timeVisible: true,
                        secondsVisible: false,
                        tickMarkFormatter: (timestamp) => {
                            const d = new Date(timestamp * 1000);
                            return d.toLocaleTimeString('en-US', {
                                timeZone: 'America/New_York',
                                hour: '2-digit',
                                minute: '2-digit',
                                hour12: false,
                            });
                        },
                    },
                    rightPriceScale: {
                        borderColor: '#e0e0e5',
                    },
                });

                const lineSeries = this.chart.addSeries(LightweightCharts.AreaSeries, {
                    topColor: 'rgba(0, 112, 243, 0.15)',
                    bottomColor: 'rgba(0, 112, 243, 0.0)',
                    lineColor: '#0070f3',
                    lineWidth: 2,
                });

                const asset = this.findAssetBySymbol(this.currentSymbol);
                const mult = asset ? (asset.price_multiplier || 1) : 1;

                // Build data with whitespace padding for full session axis
                // Standard approach: whitespace data points define the time axis,
                // actual data draws the line only where values exist.
                const sessionRange = this.getTradingSessionRange(
                    data.length > 0 ? data[0].time : Date.now() / 1000
                );

                const dataMap = new Map();
                // Real data points
                data.forEach(d => {
                    dataMap.set(d.time, { time: d.time, value: d.close * mult });
                });

                if (sessionRange) {
                    // Generate whitespace points every 5 minutes across full session
                    for (let t = sessionRange.from; t <= sessionRange.to; t += 300) {
                        if (!dataMap.has(t)) {
                            dataMap.set(t, { time: t }); // whitespace: time only, no value
                        }
                    }
                }

                // Sort by time and set data
                const lineData = Array.from(dataMap.values()).sort((a, b) => a.time - b.time);
                lineSeries.setData(lineData);

                // Set visible range to full trading session
                if (sessionRange) {
                    this.chart.timeScale().setVisibleRange({
                        from: sessionRange.from,
                        to: sessionRange.to,
                    });
                } else {
                    this.chart.timeScale().fitContent();
                }

                window.addEventListener('resize', () => {
                    if (this.chart) {
                        this.chart.applyOptions({ width: container.clientWidth });
                    }
                });
            }

            /**
             * Get current date/time in Eastern Time using Intl.DateTimeFormat.
             * Reliable across all browsers, handles DST automatically.
             */
            getETDate() {
                const now = new Date();
                const parts = new Intl.DateTimeFormat('en-US', {
                    timeZone: 'America/New_York',
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false,
                }).formatToParts(now);

                const get = (type) => parseInt(parts.find(p => p.type === type).value, 10);
                return {
                    year: get('year'),
                    month: get('month'),  // 1-based
                    day: get('day'),
                    hour: get('hour'),
                    minute: get('minute'),
                };
            }

            /**
             * Get ET‚ÜíUTC offset in seconds.
             * ET = UTC - offset, so UTC = ET + offset.
             * Returns 18000 (5h) for EST or 14400 (4h) for EDT.
             */
            getETOffsetSeconds() {
                const now = new Date();
                // Format the same instant in both UTC and ET, then compute difference
                const utcStr = now.toLocaleString('en-US', { timeZone: 'UTC' });
                const etStr = now.toLocaleString('en-US', { timeZone: 'America/New_York' });
                // Parsing locale strings back to Date gives us the wall-clock difference
                return (new Date(utcStr).getTime() - new Date(etStr).getTime()) / 1000;
            }

            /**
             * Convert ET time components to UTC Unix timestamp.
             * @param {number} year, month (1-based), day, hour, minute
             * @returns {number} UTC Unix timestamp in seconds
             */
            etToUTC(year, month, day, hour, minute) {
                const offsetSec = this.getETOffsetSeconds();
                // Build the ET time as if it were UTC, then add the offset
                const etAsUTC = Date.UTC(year, month - 1, day, hour, minute, 0) / 1000;
                return etAsUTC + offsetSec;
            }

            /**
             * Filter intraday data to current trading session based on asset type.
             * Returns filtered array of data points.
             */
            filterTodayData(data, asset) {
                if (!data || data.length === 0) return data;
                if (!asset) return data;

                const sym = asset.symbol;
                const isFutures = sym.includes('=F') || sym.includes('.L');
                const isUSEquity = sym.includes('.US');
                const isCrypto = sym.includes('.CC') || sym.includes('-USD');
                const isForex = sym.includes('.FOREX') || sym.includes('=X');

                // Crypto & Forex: last 24h, no session filtering
                if (isCrypto || isForex) {
                    if (data.length > 0) {
                        const lastTime = data[data.length - 1].time;
                        const cutoff = lastTime - 24 * 3600;
                        return data.filter(d => d.time >= cutoff);
                    }
                    return data;
                }

                const et = this.getETDate();

                if (isFutures) {
                    // Futures session: previous day 18:00 ET ‚Üí current day 17:00 ET
                    const sessionStart = this.etToUTC(et.year, et.month, et.day - 1, 18, 0);
                    const sessionEnd = this.etToUTC(et.year, et.month, et.day, 17, 0);
                    const filtered = data.filter(d => d.time >= sessionStart && d.time <= sessionEnd);
                    // If no data in current session (weekend/holiday), show last available day
                    if (filtered.length === 0 && data.length > 0) {
                        const lastTime = data[data.length - 1].time;
                        const fallbackStart = lastTime - 24 * 3600;
                        return data.filter(d => d.time >= fallbackStart);
                    }
                    return filtered;
                } else if (isUSEquity) {
                    // US equity session: 09:30 ET ‚Üí 16:00 ET
                    const sessionStart = this.etToUTC(et.year, et.month, et.day, 9, 30);
                    const sessionEnd = this.etToUTC(et.year, et.month, et.day, 16, 0);
                    const filtered = data.filter(d => d.time >= sessionStart && d.time <= sessionEnd);
                    // Fallback for weekends/holidays: show last trading day's data
                    if (filtered.length === 0 && data.length > 0) {
                        const lastTime = data[data.length - 1].time;
                        const fallbackStart = lastTime - 8 * 3600; // ~trading day window
                        return data.filter(d => d.time >= fallbackStart);
                    }
                    return filtered;
                }

                // Default: last 24h
                if (data.length > 0) {
                    const lastTime = data[data.length - 1].time;
                    const cutoff = lastTime - 24 * 3600;
                    return data.filter(d => d.time >= cutoff);
                }
                return data;
            }

            getTradingSessionRange(firstTimestamp) {
                const asset = this.findAssetBySymbol(this.currentSymbol);
                if (!asset) return null;

                const sym = asset.symbol;
                const isFutures = sym.includes('=F') || sym.includes('.L');
                const isUSEquity = sym.includes('.US');
                const isCrypto = sym.includes('.CC') || sym.includes('-USD');
                const isForex = sym.includes('.FOREX') || sym.includes('=X');

                // Crypto/Forex: just fit content (24h)
                if (isCrypto || isForex) return null;

                const et = this.getETDate();

                if (isFutures) {
                    // Futures: previous day 18:00 ET ‚Üí current day 17:00 ET
                    const startUTC = this.etToUTC(et.year, et.month, et.day - 1, 18, 0);
                    const endUTC = this.etToUTC(et.year, et.month, et.day, 17, 0);
                    return { from: startUTC, to: endUTC };
                } else if (isUSEquity) {
                    // US equity: 09:30 ET ‚Üí 16:00 ET
                    const startUTC = this.etToUTC(et.year, et.month, et.day, 9, 30);
                    const endUTC = this.etToUTC(et.year, et.month, et.day, 16, 0);
                    return { from: startUTC, to: endUTC };
                }

                return null;
            }

            renderChart(data, timeFormat) {
                const container = document.getElementById('chartContainer');
                container.innerHTML = '';

                if (this.chart) {
                    this.chart.remove();
                }

                this.chart = LightweightCharts.createChart(container, {
                    width: container.clientWidth,
                    height: 300,
                    attributionLogo: false,
                    layout: {
                        background: { color: '#ffffff' },
                        textColor: '#6e6e73',
                    },
                    grid: {
                        vertLines: { color: '#f0f0f3' },
                        horzLines: { color: '#f0f0f3' },
                    },
                    crosshair: {
                        mode: LightweightCharts.CrosshairMode.Normal,
                    },
                    timeScale: {
                        borderColor: '#e0e0e5',
                    },
                    rightPriceScale: {
                        borderColor: '#e0e0e5',
                    },
                });

                const candleSeries = this.chart.addSeries(LightweightCharts.CandlestickSeries, {
                    upColor: '#00a061',
                    downColor: '#e03c32',
                    borderDownColor: '#e03c32',
                    borderUpColor: '#00a061',
                    wickDownColor: '#e03c32',
                    wickUpColor: '#00a061',
                });

                const asset2 = this.findAssetBySymbol(this.currentSymbol);
                const mult2 = asset2 ? (asset2.price_multiplier || 1) : 1;

                // Convert time format: date strings ‚Üí LWC BusinessDay objects
                const chartData = data.map(d => {
                    let timeVal = d.time;
                    if (timeFormat === 'date' && typeof d.time === 'string') {
                        // "YYYY-MM-DD" ‚Üí { year, month, day }
                        const parts = d.time.split('-');
                        timeVal = {
                            year: parseInt(parts[0], 10),
                            month: parseInt(parts[1], 10),
                            day: parseInt(parts[2], 10),
                        };
                    }
                    return {
                        time: timeVal,
                        open: d.open * mult2,
                        high: d.high * mult2,
                        low: d.low * mult2,
                        close: d.close * mult2,
                    };
                });

                candleSeries.setData(chartData);
                this.chart.timeScale().fitContent();

                // Handle resize
                window.addEventListener('resize', () => {
                    if (this.chart) {
                        this.chart.applyOptions({
                            width: container.clientWidth,
                        });
                    }
                });
            }

            changeTimeRange(range) {
                // Update active button
                document.querySelectorAll('.time-range-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[data-range="${range}"]`).classList.add('active');

                // Show ET timezone label for intraday
                const tzLabel = document.getElementById('tzLabel');
                if (tzLabel) tzLabel.style.display = range === '1d' ? 'inline' : 'none';
                
                // Reload chart
                if (this.currentSymbol) {
                    this.loadChart(this.currentSymbol, range);
                }
            }

            updateStatus(status) {
                const indicator = document.getElementById('status');
                indicator.className = `status-indicator ${status}`;
            }

            showError(message) {
                document.getElementById('marketList').innerHTML = `<div class="error">${message}</div>`;
            }
        }

        // Global app instance
        const app = new MarketDashboard();
    </script>
</body>
</html>